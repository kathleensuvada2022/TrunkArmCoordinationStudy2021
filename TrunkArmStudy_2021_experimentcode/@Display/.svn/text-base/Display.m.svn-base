classdef Display < handle
    %DISPLAY Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        home;   % struct containing home target variables
        target; % struct containing variables for the target
        radius = 0.05;
        figureHandle;
        axesHandle;
        lineSeriesHandle;
        planeHandle;
        planeTop;
        homeSphereHandle;
        targetSphereHandle;
        endEffectorHandle;
        shoulderPositionHandle;
        fingerTipPositionHandle;
        fingerTipPositionTraceHandle;
        fingerTipPositionTraceIteration=0;
        fingerTipPositionTrace = zeros(3,300);
        
        % position where the end of the arm is at 45 degrees shoulder flexion
        % and 90 degrees elbow flexion.  Used to compute target position.
        distalEndOfArmAtHome = [ 0.1722, 0.5902, 0.3596 ];
        shoulderPosition = [ 0.25, 0.4, -0.1 ];
        
        % these angles are the saved angles and defined as the clinically
        % relevant angles
        % -- is sf=0,e=0 ;  < is s~30,ef~135 ;  for right arm: > is sf=30,e=135
        shoulderFlexionAngle = 45*(pi/180);
        elbowAngle = 90*(pi/180);
        shoulderAbductionAngle = 0;
        
        upperArmLength = 0.352;
        lowerArmLength = 0.287;
        handLength = 0.191;
        elbowToEndEffector = 0.232;
        fingerTipPosition = [0 0 0];        % finger tip position for display
        shoulderToEndEffector=1000; % in meters. this is defaulted to a large number so that the default abudction force is small.
        
    end
    
    methods
        % constructor
        function obj = Display( robot, judp, obj ) %#ok<INUSD>
            
            % initialize class properties
            obj.home.position = [0 0 0];
            obj.home.iterationsInside = 0;
            obj.home.visible = 0;
			obj.target.position = [0, 0.01, 0];
            obj.target.iterations = 0;
            
            % get arm selected
            obj.StartBlender('Left', judp);
            
        end
       
        % destructor
        function delete(obj, arm, judp )
            obj.CloseDisplay(arm, judp);
            %stop( obj.updateDisplayTimer );
            %delete( obj.updateDisplayTimer );
        end
        
        
        function obj = StartBlender( obj, arm, judp)
            if strcmp( arm, 'Right' )
                % change this to a right arm exe
                create_async('Init','right');
            else
                % change this to a left arm exe
                create_async('Init','left');
            end
            
            pause(3);
            
            % if not disconnected, then disconnect
            isSocketClosed = get( judp.socketReceive, 'Closed' );
            if strcmp(isSocketClosed,'off')
                judp.Disconnect;
            end
            
            % Create connection to udp connection
            judp.Connect;
            
            %pause(3);
            
        end
        
        
        function obj = ComputeArmAngles( obj, endEffectorPosition, endEffectorRotation, arm )
            
            % compute shoulder abduction angle
            obj.ComputeShoulderAbductionAngle( endEffectorPosition );
            %obj.shoulderAbductionAngle = 0; %temp

            %z = endEffectorPosition(3) - obj.shoulderPosition(3);
            %xyz = norm( endEffectorPosition - obj.shoulderPosition );
            %obj.upperArmLength + obj.elbowToEndEffector;
            %sqrt( abs(endEffectorPosition - obj.shoulderPosition)^2 ...
            %+ abs(endEffectorPosition(1) - obj.shoulderPosition(1))^2 );
            %obj.shoulderAbductionAngle = asin( z/xyz );
            
            
            % compute elbow position
            elbowPosition(1) = endEffectorPosition(1)...
                - (obj.elbowToEndEffector * cos(endEffectorRotation) * cos(obj.shoulderAbductionAngle));
            
            if strcmp( arm, 'Left' )
                elbowPosition(1) = endEffectorPosition(1)...
                    - (obj.elbowToEndEffector * cos(endEffectorRotation) * cos(obj.shoulderAbductionAngle));
            end
            
            elbowPosition(2) = endEffectorPosition(2)...
                + (obj.elbowToEndEffector * sin(endEffectorRotation) * cos(obj.shoulderAbductionAngle));
            
            if strcmp( arm, 'Left' )
                elbowPosition(2) = endEffectorPosition(2)...
                    - (obj.elbowToEndEffector * sin(endEffectorRotation) * cos(obj.shoulderAbductionAngle));
            end
            
            elbowPosition(3) = endEffectorPosition(3)...
                - (obj.elbowToEndEffector * sin(obj.shoulderAbductionAngle));
            
            x = elbowPosition(1) - obj.shoulderPosition(1);
            y = elbowPosition(2) - obj.shoulderPosition(2);
            if strcmp( arm, 'Left' )
                obj.shoulderFlexionAngle = - atan2( y, x ) + pi;
                obj.elbowAngle = pi - endEffectorRotation - obj.shoulderFlexionAngle;
            else
                % untested
                obj.shoulderFlexionAngle = atan2( y, x ) + pi;
                obj.elbowAngle = endEffectorRotation + obj.shoulderFlexionAngle;
            end
        end
        
        
        function obj = ComputeShoulderAbductionAngle( obj, endEffectorPosition )
                
            xyz = endEffectorPosition - obj.shoulderPosition;
            z = endEffectorPosition(3) - obj.shoulderPosition(3);
            
            obj.shoulderAbductionAngle = asin( z/norm(xyz) );
            
        end
        
        
        function obj = ComputeFingerTipPosition( obj, endEffectorPosition,...
                endEffectorRotation, arm )
            
                
            if strcmp(arm,'Right')
                
                obj.fingerTipPosition(1) = endEffectorPosition(1) +...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * cos(endEffectorRotation) * cos(obj.shoulderAbductionAngle) );
                
                obj.fingerTipPosition(2) = endEffectorPosition(2) -...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * sin(endEffectorRotation) * cos(obj.shoulderAbductionAngle) );
                
                obj.fingerTipPosition(3) = endEffectorPosition(3) +...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * sin(obj.shoulderAbductionAngle) );
                
                
            else % left arm
                
                
                obj.fingerTipPosition(1) = endEffectorPosition(1) +...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * cos(endEffectorRotation) * cos(obj.shoulderAbductionAngle) );
                
                obj.fingerTipPosition(2) = endEffectorPosition(2) +...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * sin(endEffectorRotation) * cos(obj.shoulderAbductionAngle) );
                
                obj.fingerTipPosition(3) = endEffectorPosition(3) +...
                    ( (obj.handLength + obj.lowerArmLength - obj.elbowToEndEffector)...
                    * sin(obj.shoulderAbductionAngle) );

            end
            
        end
        
        
        function obj = CloseDisplay( obj, arm, judp )    % should I change these last two arguments to ~ or remove?
            % terminate blender program
			% end thread using blender
			% close socket
            judp.Write('disconnect');
            disp('disconnect sent');
            
            disp('UDP connection closed');

            pause(3);
            
            judp.Disconnect;
            
            %% end thread
            %% CHANGE THESE CALLS TO RIGHT AND LEFT ARM FUNCTION CALLS
            if strcmp(arm, 'Right')
                try
                    % use dos command to remove program in the second thread
                    !taskkill /f /im visual_right_arm.exe
                catch
                    disp('Blender could not be closed.  Please close manually.');
                end

                % finish the separate thread - change this to left or right arm
                create_async('Finish','right');
            
            else
                try
                    % use dos command to remove program in the second thread
                    !taskkill /f /im visual_left_arm.exe
                catch
                    disp('Blender could not be closed.  Please close manually.');
                end

                % finish the separate thread - change this to left or right arm
                create_async('Finish','left');
                
            end

            %{
			if ishandle(obj.figureHandle)
                close(obj.figureHandle);
            end
			%}
        end
                
        
        function obj = ComputeShoulderPosition( obj, endEffectorPosition, endEffectorRotation, shoulderFlexionAngle, arm )

            % compute shoulder position using arm measurements and initial end effector position
            
            if strcmp(arm,'Right')
                
                obj.shoulderPosition(1) = endEffectorPosition(1) - ...
                    obj.elbowToEndEffector * cos(endEffectorRotation)  + ...
                    obj.upperArmLength * cos(shoulderFlexionAngle);
                
                obj.shoulderPosition(2) = endEffectorPosition(2) +...
                    obj.elbowToEndEffector * sin(endEffectorRotation) +...
                    obj.upperArmLength * sin(shoulderFlexionAngle);

            % left arm
            else
                
                % shoulder x position
                obj.shoulderPosition(1) = endEffectorPosition(1) +...
                    obj.upperArmLength * cos( shoulderFlexionAngle ) -...
                    obj.elbowToEndEffector * cos( endEffectorRotation );
                
                % shoulder y position
                obj.shoulderPosition(2) = endEffectorPosition(2) -...
                    obj.upperArmLength * sin( shoulderFlexionAngle ) -...
                    obj.elbowToEndEffector * sin( endEffectorRotation );
                
            end
            
            obj.shoulderPosition(3) = endEffectorPosition(3);
            
        end
        
        
        function obj = SetTargetPosition( obj, arm, shoulderFlexionAngle, elbowAngle, shoulderAbductionAngle, judp )
            
            if nargin == 1  % if there are no inputs
                shoulderFlexionAngle = obj.shoulderFlexionAngle;
                elbowAngle = obj.elbowAngle;
                shoulderAbductionAngle = obj.shoulderAbductionAngle;
            end
            
            if ( isnan(shoulderFlexionAngle)  ||  isnan(elbowAngle)  ||  isnan(shoulderAbductionAngle) )
                obj.target.position(1) = 0;
                obj.target.position(2) = 0;
                obj.target.position(3) = 0;
                
            else
                % compute forward kinematics using desired arm angles to determine target position
                relativeElbowAngle = elbowAngle + shoulderFlexionAngle;
                
                distance(1) = obj.upperArmLength * cos(shoulderAbductionAngle) * cos(shoulderFlexionAngle) ...
                    + ( (obj.lowerArmLength + obj.handLength) * cos(shoulderAbductionAngle) * cos(relativeElbowAngle) );
                
                distance(2) = obj.upperArmLength * cos(shoulderAbductionAngle) * sin(shoulderFlexionAngle)...
                    + ( (obj.lowerArmLength + obj.handLength) * cos(shoulderAbductionAngle) * sin(relativeElbowAngle) );
                
                distance(3) = sin(shoulderAbductionAngle) * ( obj.upperArmLength + obj.lowerArmLength + obj.handLength );
                
                
                if strcmp(arm,'Right')
                    obj.target.position(2) = obj.shoulderPosition(2) - distance(2);
                    
                else % left arm
                    obj.target.position(2) = obj.shoulderPosition(2) + distance(2);
                end
                
                obj.target.position(1) = obj.shoulderPosition(1) - distance(1);
                obj.target.position(3) = obj.home.position(3);%shoulderPosition(3) + distance(3);
            
            end
            
            %{
            [sphereX,sphereY,sphereZ] = obj.ComputeSphere( obj.radius,obj.target.position );
            set( obj.targetSphereHandle, 'XData',sphereX, 'YData',sphereY, 'ZData',sphereZ );
            %}
            
			blenderAngles = [ shoulderFlexionAngle, elbowAngle,...
                shoulderAbductionAngle ] * 180/pi;
            judp.Write(['target position ', num2str(blenderAngles(1)), ' ',...
                num2str(blenderAngles(2)), ' ', num2str(blenderAngles(3)) ] );

        end
        
        
        function obj = SetHomePosition( obj, endEffectorPosition, endEffectorRotation, arm, judp )
            
            % place new home position at the finger tips
            obj.ComputeShoulderAbductionAngle( endEffectorPosition );
            obj.ComputeFingerTipPosition( endEffectorPosition, endEffectorRotation, arm );
            obj.home.position = obj.fingerTipPosition;
            obj.ComputeArmAngles( endEffectorPosition, endEffectorRotation, arm );

            % send arm angles where the home position should be set
            blenderAngles = [ obj.shoulderFlexionAngle, obj.elbowAngle,...
                obj.shoulderAbductionAngle ] * 180/pi;
            judp.Write( [ 'home position ',  num2str(blenderAngles(1)), ' ',...
                num2str(blenderAngles(2)), ' ',  num2str(blenderAngles(3)) ] );

            % compute a new sphere at the new home position
            %{
			[sphereX,sphereY,sphereZ] = obj.ComputeSphere( obj.radius, obj.home.position );
            set( obj.homeSphereHandle, 'XData',sphereX, 'YData',sphereY, 'ZData',sphereZ );
            %}
			% send 'home position x y z'
        end
        
        
        function obj = RefreshDisplay( obj, experiment, judp, arm )
            
            % compute new end effector sphere
            %[SphereX,SphereY,SphereZ] = obj.ComputeSphere( obj.radius, obj.fingerTipPosition );
            
            % redisplay the end effector sphere
            %set( obj.fingerTipPositionHandle, 'XData',SphereX, 'YData',SphereY, 'ZData',SphereZ );
            
            % display the arm at the new angles 
            %obj.shoulderAbductionAngle = 0; 
            %obj.shoulderFlexionAngle = 0;
            %obj.elbowAngle = 0;
            
            % convert clincal angles to angles for blender to use
            blenderAngles = obj.ConvertToBlenderAngles(arm);
            %blenderAngles=[70,-10,0];
            judp.Write( ['arm angles ', num2str(blenderAngles(1)), ' ',...
                num2str(blenderAngles(2)), ' ', num2str(blenderAngles(3))] );
            
            
            % display the trace of the finger tip position if the trial is running
            if experiment.isRecordingData == 1  &&  experiment.isArmOnTable == 0
                obj.fingerTipPositionTraceIteration = obj.fingerTipPositionTraceIteration + 1;
                obj.fingerTipPositionTrace(:,obj.fingerTipPositionTraceIteration) = obj.fingerTipPosition;
                
                % draw a point from the previous giner tip position to the
                % current position
                if mod( obj.fingerTipPositionTraceIteration, 5 ) == 0
                    judp.Write( 'trace append' );
                end
                
                
                %set( obj.fingerTipPositionTraceHandle,...
                %    'XData',obj.fingerTipPositionTrace( 1, 1:obj.fingerTipPositionTraceIteration) ,...
                %    'YData',obj.fingerTipPositionTrace( 2, 1:obj.fingerTipPositionTraceIteration) ,...
                %    'ZData',obj.fingerTipPositionTrace( 3, 1:obj.fingerTipPositionTraceIteration) );
            end
            
            %refreshdata( obj.figureHandle, 'caller' ); % Evaluate y in the function workspace
            %drawnow update; 
        end
        function [ blenderAngles, obj ] = ConvertToBlenderAngles(obj, arm)
            % convert to angles to degrees.  abduction is negative for the
            % shoulder abduction angle, since blender uses a right handed
            % coordinate system.
            if strcmp(arm,'Left')
                blenderAngles(1) = -obj.shoulderFlexionAngle*180/pi; 
                blenderAngles(2) = obj.elbowAngle*180/pi; 
            else
                blenderAngles(1) = obj.shoulderFlexionAngle*180/pi; 
                blenderAngles(2) = -obj.elbowAngle*180/pi; 
            end
            
            blenderAngles(3) = obj.shoulderAbductionAngle*180/pi; 
        end
    
        
    end
    
    methods (Static)
        %{
		function SetFigureProperties( figureHandle, axesHandle )
            
            hold( axesHandle, 'on' );
            
            % put the plot on the second monitor
            monitorPosition = get(0,'monitorpositions');
            figurePosition = monitorPosition(end,:);
            if length(monitorPosition(:,1)) ==2
                figurePosition(3) = figurePosition(3) - monitorPosition(1,3);
            end
            set( figureHandle, 'Position', figurePosition );
            
            set( axesHandle, 'projection', 'perspective');
            
            camlight('right');
            
            axis(axesHandle,'vis3d');    % prevents zooming to fill screen when rotating in 3D
            axis(axesHandle,'equal');    % prevents zooming to fill screen when rotating in 3D
            axis(axesHandle,'off');     % Don't draw axes
            %axis(axesHandle,'tight');    % prevents zooming to fill screen when rotating in 3D
            set(figureHandle, 'color', [0.0 0.0 0.25]); % Background color dark blue
            set(axesHandle,'LooseInset',get(axesHandle,'TightInset'));
            rotate3d on;
            
            set( figureHandle, 'CloseRequestFcn', @(x,y)disp('Please close the interface window to close the program') );
            
            limit_x = [ -2, 2 ];
            limit_y = [ -2, 2 ];
            limit_z = [ -2, 2 ];
            xlim( axesHandle, limit_x );
            ylim( axesHandle, limit_y );
            zlim( axesHandle, limit_z );
            view( axesHandle, 180, 30);
        end
		%}
        %{
        function [x,y,z] = ComputeSphere(radius,location)
            % taken from: http://www.mathworks.com/matlabcentral/newsreader/view_thread/169373
            phi=linspace(0,pi,30);
            theta=linspace(0,2*pi,40);
            [phi,theta]=meshgrid(phi,theta);

            x = radius * sin(phi).* cos(theta) + location(1);
            y = radius * sin(phi).* sin(theta) + location(2);
            z = radius * cos(phi) + location(3); 
        end
        %}
    end
     
end

