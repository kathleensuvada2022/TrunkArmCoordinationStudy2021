function [ initializeRobot, mainWindow ] = CreateInitializeRobotCallbacks(...
    initializeRobot, mainWindow, robot, haptic, display, participantParameters, setTargets, timerObject, experiment, judp )

set(initializeRobot.inertiaEditBox,...
    'Callback',{@inertiaEditBox_Callback,mainWindow, robot});

set(initializeRobot.rightRadioButton,...
    'Callback',{@rightRadioButton_Callback,mainWindow,robot,initializeRobot,display, haptic, judp, timerObject});
set(initializeRobot.leftRadioButton,...
    'Callback',{@leftRadioButton_Callback,mainWindow,robot,initializeRobot,display, haptic, judp, timerObject});

set(initializeRobot.browsePushButton,...
    'Callback',{@browsePushButton_Callback,initializeRobot});
set(initializeRobot.frequencyPopUpMenu,...
    'Callback',{@frequencyPopUpMenu_Callback,mainWindow,robot});

set(initializeRobot.locateShoulderPushButton,...
    'Callback',{@locateShoulderPushButton_Callback,mainWindow,robot,display,initializeRobot,participantParameters,setTargets,...
    haptic,timerObject,experiment, judp});
set(initializeRobot.weighArmPushButton,...
    'Callback',{@weighArmPushButton_Callback,mainWindow,robot,initializeRobot,participantParameters});
set(initializeRobot.participantParametersPushButton,...
    'Callback',{@participantParametersPushButton_Callback,mainWindow,robot,participantParameters,timerObject});

set(initializeRobot.okPushButton,...
    'Callback',{@okPushButton_Callback,mainWindow,robot,initializeRobot});
set(initializeRobot.cancelPushButton,...
    'Callback',{@cancelPushButton_Callback,mainWindow,robot,initializeRobot});

set( initializeRobot.figureHandle, 'CloseRequestFcn', @(x,y)disp('Please click OK or Cancel') );

end

function inertiaEditBox_Callback(hObject, eventdata, mainWindow, robot )

inertiaValue = str2double ( get( hObject, 'String' ) );
if inertiaValue > 16 || inertiaValue < 4
    disp('Inertia should be no more than 16 and no less than 4 kg*m^2');
    return;
end
robot.SetInertia( inertiaValue );
%set( mainWindow.statusPanel.secondColumn(8), 'String',
%num2str(robot.SetInertia) );   %needed?

end

%% try just using a callback for the hapticgroup
function rightRadioButton_Callback(hObject, eventdata, mainWindow, robot, initializeRobot, display, haptic, judp, timerObject)
newArm = 'Right';

disp('Please wait. Opening right arm render...');
% get old arm
oldArm = get( mainWindow.statusPanel.secondColumn(6), 'String' );

% Inverse kinematics function in visualfeedback class is computed  
% differently according to the arm used
set( mainWindow.statusPanel.secondColumn(6), 'String', newArm);
set(initializeRobot.armButtonGroup,'SelectedObject',hObject);

%view( display.axesHandle, 180, 30 );
% close thread/blender and open a new thread/blender showing the right arm
stop( timerObject );

display.CloseDisplay(oldArm, judp);

display.StartBlender(newArm, judp);

start( timerObject );

% set position of vertical effect
haptic.verticalEffectPosition = [0, 0.04, 0];
if haptic.isVerticalEffectCreated == 1
    haptic.SetPosition(haptic.verticalEffectPosition,haptic.verticalEffectName);
end

end

function leftRadioButton_Callback(hObject, eventdata, mainWindow, robot, initializeRobot, display, haptic, judp, timerObject)
newArm = 'Left';

disp('Please wait.  Opening left arm render...');

oldArm = get( mainWindow.statusPanel.secondColumn(6), 'String' );

% Inverse kinematics function in visualfeedback class is computed
% differently according to the arm used
set( mainWindow.statusPanel.secondColumn(6), 'String', newArm);
set(initializeRobot.armButtonGroup,'SelectedObject',hObject);

%view( display.axesHandle, 0, 30 );
% change camera angle to a left handed view
% close thread/blender and open a new thread/blender showing the left arm  
% close thread/blender and open a new thread/blender showing the right arm
stop( timerObject );

display.CloseDisplay(oldArm, judp);

display.StartBlender(newArm, judp);

start( timerObject );

% set position of vertical effect
haptic.verticalEffectPosition = [0, -0.04, 0];
if haptic.isVerticalEffectCreated == 1
    haptic.SetPosition(haptic.verticalEffectPosition,haptic.verticalEffectName);
end

end

%%
function browsePushButton_Callback(hObject, eventdata, initializeRobot )
folderName = uigetdir(pwd);
if folderName ~= 0
    set(initializeRobot.filenameEditBox,'String',folderName);
end
end

function frequencyPopUpMenu_Callback(hObject, eventdata, mainWindow, robot)
% --- NOT YET IMPLEMENTED - CURRENTLY DISABLED ---
% may create two timers. one for graphics (~50-60 hz). other timer for getting data from robot. 
% this popup would change the frequency getting data from the robot.
end


function participantParametersPushButton_Callback(hObject, eventdata, mainWindow, robot, participantParameters, timerObject )

stop(timerObject);

% make participant parameters window visible and switch to modal to not allow other windows to be clicked
set( participantParameters.figureHandle, 'Visible','On');%, 'WindowStyle','modal' );

start(timerObject);

end


function locateShoulderPushButton_Callback(hObject, eventdata, mainWindow,...
    robot, display, initializeRobot, participantParameters, setTargets,...
    haptic, timerObject, experiment, judp )

stop(timerObject);

% switch the robot to a fixed state to keep the participant's arm still
robot.SwitchState('fixed');
set(mainWindow.trialConditionsPanel.statePopUpMenu,'String',{'fixed','normal','off'});
set(mainWindow.trialConditionsPanel.statePopUpMenu,'Value',1);

% get current end effector position, arm selected, and elbow flexion angle 
% for computing the location of the shoulder
shoulderFlexionAngle = get( participantParameters.shoulderFlexionEditBox, 'String' );
shoulderFlexionAngle = str2double(shoulderFlexionAngle) *pi/180;
arm = get( mainWindow.statusPanel.secondColumn(6), 'String' );
if iscell(arm)
    arm = arm{1};
end
robot.SetForceGetInfo(arm);
display.ComputeShoulderAbductionAngle(robot.endEffectorPosition);
display.ComputeFingerTipPosition( robot.endEffectorPosition, robot.endEffectorRotation, arm );

display.ComputeShoulderPosition( robot.endEffectorPosition, robot.endEffectorRotation(1), shoulderFlexionAngle, arm );

% temp
%[ x,y,z ] = display.ComputeSphere( display.radius, display.shoulderPosition );
%set( display.shoulderPositionHandle, 'XData',x, 'YData',y, 'ZData',z );

% set the position of the home sphere at the tip of the hand
display.SetHomePosition( robot.endEffectorPosition, robot.endEffectorRotation(1), arm, judp );

% set the home position at the tip of the middle finger
experiment.tableZ = display.fingerTipPosition(3);

% compute and set new target position
targetShoulderAbductionAngle = get( setTargets.shoulderAbductionAngleEditBox, 'String' );
targetShoulderAbductionAngle = str2double(targetShoulderAbductionAngle) * pi/180;
targetShoulderAbductionAngle = targetShoulderAbductionAngle - pi/2;

targetShoulderFlexionAngle = get( setTargets.shoulderFlexionAngleEditBox, 'String' );
targetShoulderFlexionAngle = str2double(targetShoulderFlexionAngle) * pi/180;

targetElbowAngle = get( setTargets.elbowAngleEditBox, 'String' );
targetElbowAngle = str2double(targetElbowAngle) * pi/180;


display.SetTargetPosition( arm, targetShoulderFlexionAngle, targetElbowAngle, targetShoulderAbductionAngle, judp );

% set the target position at the computed position
% send 'target position x y z'
%[sphereX,sphereY,sphereZ] = display.ComputeSphere( display.radius, display.target.position );
%set( display.targetSphereHandle, 'XData',sphereX, 'YData',sphereY, 'ZData',sphereZ );

% set new position in setTargets window
set( setTargets.xEditBox, 'String', num2str(display.target.position(1)) );
set( setTargets.yEditBox, 'String', num2str(display.target.position(2)) );
set( setTargets.zEditBox, 'String', num2str(display.target.position(3)) );

% compute new abduction max force value ( force = torque / r ) using the distance 
% from the shoulder to the end effector as r.  Only need to set this value once.
% -- Create button to set the distance from shoulder to the end effector
if display.shoulderToEndEffector == 1000
    display.shoulderToEndEffector = norm( robot.endEffectorPosition - display.shoulderPosition );
    torque = str2double( get( participantParameters.abductionMaxTorqueEditBox, 'String' ) );
    force = torque / display.shoulderToEndEffector;
    set( participantParameters.abductionMaxForceEditBox, 'String', num2str(force,'%3.2f') );
end

fprintf('Shoulder located\n');

start(timerObject);

end


function weighArmPushButton_Callback(hObject, eventdata, mainWindow, robot, initializeRobot, participantParameters )

% Acquire limb weight samples  
maxLimbWeightSamples = 400;
limbWeightSamples = zeros(1,maxLimbWeightSamples);
arm = get( mainWindow.statusPanel.secondColumn(6), 'String' );
for sample = 1:maxLimbWeightSamples
    robot.SetForceGetInfo(arm);
    limbWeightSamples(sample) = robot.endEffectorForce(3);
end

% Average the samples to get a limb weight value
limbWeight = mean(limbWeightSamples);
set( participantParameters.limbWeightEditBox, 'String', num2str(-limbWeight,'%3.2f') );
fprintf('The weight of the participant''s limb is %3.2f N\n',-limbWeight);

% switch the robot back to a normal state
robot.SwitchState('normal');
set(mainWindow.trialConditionsPanel.statePopUpMenu,'String',{'normal','fixed','off'});
set(mainWindow.trialConditionsPanel.statePopUpMenu,'Value',1);

end


function okPushButton_Callback(hObject, eventdata, mainWindow, robot, initializeRobot )

% save fileanme and the arm in the figure handle properties
armObject = get( initializeRobot.armButtonGroup, 'SelectedObject' );
setappdata( initializeRobot.figureHandle, 'arm',armObject );
arm = get( armObject, 'String' );

filename = get( initializeRobot.filenameEditBox, 'String' );
setappdata(initializeRobot.figureHandle,'filename',filename);
set( mainWindow.statusPanel.secondColumn(11), 'String', filename );

% make initialize robot window invisible and save what's been done
set(initializeRobot.figureHandle, 'Visible','off', 'WindowStyle','normal');

end


function cancelPushButton_Callback(hObject, eventdata, mainWindow, robot, initializeRobot )

% make initialize robot window invisible and revert to previous values
set(initializeRobot.figureHandle, 'Visible','off', 'WindowStyle','normal');

% revert back to previous arm and filename for initialize robot window only
armObject = getappdata( initializeRobot.figureHandle,'arm' );
set( initializeRobot.armButtonGroup, 'SelectedObject', armObject );
arm = get( armObject, 'String' );

filename = getappdata(initializeRobot.figureHandle,'filename');
set( initializeRobot.filenameEditBox, 'String', filename );

end

